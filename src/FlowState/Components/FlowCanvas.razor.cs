// <autogenerated />
using FlowState.Models;
using FlowState.Models.Dom;
using FlowState.Models.Events;
using FlowState.Models.Serializable;
using Microsoft.AspNetCore.Components;
using Microsoft.AspNetCore.Components.Web;
using Microsoft.JSInterop;

namespace FlowState.Components
{
    public partial class FlowCanvas : IDisposable
    {
        private string id = Guid.NewGuid().ToString();


        [EditorRequired]
        [Parameter]
        public FlowGraph Graph { get; set; }

        [EditorRequired]
        [Parameter]
        public string Width { get; set; } = "100%";
        [EditorRequired]
        [Parameter]
        public string Height { get; set; } = "100%";
        [Parameter] public string Style { get; set; } = string.Empty;
        [Parameter] public string Class { get; set; } = "flow-canvas";

        [Parameter] public int OffsetX { get; set; } = 0;
        [Parameter] public int OffsetY { get; set; } = 0;

        [Parameter] public double MinZoom { get; set; } = 0.2;
        [Parameter] public double MaxZoom { get; set; } = 2.0;

        [Parameter] public double Zoom { get; set; } = 1.0;
        [Parameter] public EventCallback<PanEventArgs> OnPanned { get; set; }
        [Parameter] public EventCallback<double> OnZoomed { get; set; }

        /// <summary>
        /// Optional override for the background grid pattern.
        /// </summary>
        [Parameter] public string GridStyle { get; set; } = string.Empty;

        private bool isPanning;
        private double startX, startY;
        private double lastOffsetX, lastOffsetY;
        private ElementReference canvasRef;
        private IJSObjectReference module;

        // Default dotted grid pattern
        private const string DefaultGridStyle =
            """
        background-image:radial-gradient(#000 1px, transparent 1px);
        background-size:32px 32px;
        background-repeat:repeat;
        """;

        private string EffectiveGridStyle =>
          $"""
    position:absolute;
    inset:0;
    {(string.IsNullOrWhiteSpace(GridStyle) ? DefaultGridStyle : GridStyle)};
    background-position:{OffsetX % (32 * Zoom)}px {OffsetY % (32 * Zoom)}px;
    background-size:{32 * Zoom}px {32 * Zoom}px;
    """;


        private string ContentStyle =>
            $"""
    position:absolute;
    top:0;left:0;
    transform:translate3d({OffsetX}px,{OffsetY}px,0) scale({Zoom});
    transform-origin: 0 0;
    will-change:transform;
    """;

    protected override void OnInitialized()
        {
            if (Graph == null)
                throw new InvalidOperationException("FlowCanvas requires a valid FlowGraph instance.");
            Graph.NodeAdded += Refresh;
        }

        protected override async Task OnAfterRenderAsync(bool firstRender)
        {
            await base.OnAfterRenderAsync(firstRender);

            if (!firstRender)
                return;

            module = await JS.InvokeAsync<IJSObjectReference>("import", "/_content/FlowState/flowCanvas.js");
        }

        private void Refresh(object? sender, EventArgs e)
        {
            StateHasChanged();
        }
        private void StartPan(PointerEventArgs e)
        {
            isPanning = true;
            startX = e.ClientX;
            startY = e.ClientY;
            lastOffsetX = OffsetX;
            lastOffsetY = OffsetY;
        }

        private void EndPan(EventArgs e) => isPanning = false;

        private async Task PanMove(PointerEventArgs e)
        {
            if (!isPanning) return;
            OffsetX = (int)(lastOffsetX + (e.ClientX - startX));
            OffsetY = (int)(lastOffsetY + (e.ClientY - startY));
            await OnPanned.InvokeAsync(new PanEventArgs(OffsetX, OffsetY));
            StateHasChanged();
        }

        private async Task OnWheel(WheelEventArgs e)
        {

            if (module == null) return;

            // Scroll up = zoom in, scroll down = zoom out
            double delta = e.DeltaY < 0 ? 0.02 : -0.02;
            double newZoom = Math.Clamp(Zoom + delta, MinZoom, MaxZoom);

            if (Math.Abs(newZoom - Zoom) < 0.001) return; // already at limit

            var rect = await module.InvokeAsync<DOMRect>("getBoundingClientRect", canvasRef);
            double mouseX = e.ClientX - rect.Left;
            double mouseY = e.ClientY - rect.Top;

            // Adjust offsets so zoom is centered at cursor
            OffsetX = (int)(mouseX - (mouseX - OffsetX) * (newZoom / Zoom));
            OffsetY = (int)(mouseY - (mouseY - OffsetY) * (newZoom / Zoom));

            Zoom = newZoom;

            await OnZoomed.InvokeAsync(Zoom);
            StateHasChanged();
        }

        public void SetViewport(CanvasProperties canvasProperties)
        {
            OffsetX = canvasProperties.OffsetX;
            OffsetY = canvasProperties.OffsetY;
            Zoom = canvasProperties.Zoom;
            StateHasChanged();
        }
        public void SetOffset(int offsetX, int offsetY)
        {
            OffsetX = offsetX;
            OffsetY = offsetY;
            StateHasChanged();
        }

        public void SetZoom(double zoom)
        {
            Zoom = Math.Clamp(zoom, MinZoom, MaxZoom);
            StateHasChanged();
        }

        public CanvasProperties GetViewportProperties() =>
            new CanvasProperties
            {
                OffsetX = OffsetX,
                OffsetY = OffsetY,
                Zoom = Zoom
            };

        public void Dispose()
        {
            Graph.NodeAdded -= Refresh;
        }
    }
}