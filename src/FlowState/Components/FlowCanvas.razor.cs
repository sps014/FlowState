// <autogenerated />
using System.Drawing;
using FlowState.Models;
using FlowState.Models.Dom;
using FlowState.Models.Events;
using FlowState.Models.Serializable;
using Microsoft.AspNetCore.Components;
using Microsoft.AspNetCore.Components.Web;
using Microsoft.JSInterop;

namespace FlowState.Components
{
    public partial class FlowCanvas : IAsyncDisposable
    {
        public string Id { get; } = Guid.NewGuid().ToString();

        [EditorRequired]
        [Parameter]
        public FlowGraph Graph { get; set; }

        [EditorRequired]
        [Parameter]
        public string Width { get; set; } = "100%";
        [EditorRequired]
        [Parameter]
        public string Height { get; set; } = "100%";
        [Parameter] public string Style { get; set; } = string.Empty;
        [Parameter] public string Class { get; set; } = "flow-canvas";

        [Parameter] public double MinZoom { get; set; } = 0.2;
        [Parameter] public double MaxZoom { get; set; } = 2.0;

        [Parameter] public double Zoom { get; set; } = 1.0;
        [Parameter] public EventCallback<PanEventArgs> OnPanned { get; set; }
        [Parameter] public EventCallback<double> OnZoomed { get; set; }

        /// <summary>
        /// Optional override for the background grid pattern.
        /// </summary>
        [Parameter] public string GridStyle { get; set; } = string.Empty;

        [Parameter] public Size GridBackgroundSize { get; set; } = new Size(32, 32);

        private bool isPanning;
        private double startX, startY;
        private double lastOffsetX, lastOffsetY;

        private ElementReference gridRef;
        private ElementReference canvasRef;
        private ElementReference flowContentRef;
        private IJSObjectReference module;

        private DotNetObjectReference<FlowCanvas> dotnetObjRef;

        // Default dotted grid pattern
        private const string DefaultGridStyle =
            """
        background-image:radial-gradient(#000 1px, transparent 1px);
        background-repeat:repeat;
        """;

        private string EffectiveGridStyle =>
          $"""
    position:absolute;
    inset:0;
    {(string.IsNullOrWhiteSpace(GridStyle) ? DefaultGridStyle : GridStyle)};
    background-size:{GridBackgroundSize.Width * Zoom}px {GridBackgroundSize.Height * Zoom}px;
    """;


        private string ContentStyle =>
            $"""
    position:absolute;
    top:0;left:0;
    transform-origin: 0 0;
    will-change:transform;
    """;

    protected override void OnInitialized()
        {
            if (Graph == null)
                throw new InvalidOperationException("FlowCanvas requires a valid FlowGraph instance.");
                
            Graph.Canvas = this;
            Graph.NodeAdded += Refresh;
            dotnetObjRef = DotNetObjectReference.Create(this);
        }

        protected override async Task OnAfterRenderAsync(bool firstRender)
        {
            await base.OnAfterRenderAsync(firstRender);

            if (!firstRender)
                return;

            module = await JS.InvokeAsync<IJSObjectReference>("import", "/_content/FlowState/flowCanvas.js");
            await module.InvokeVoidAsync("setGridBackgroundSize", GridBackgroundSize.Width, GridBackgroundSize.Height);
            await module.InvokeVoidAsync("setupCanvasEvents", canvasRef, gridRef, flowContentRef, dotnetObjRef);
        }

        private void Refresh(object? sender, EventArgs e)
        {
            StateHasChanged();
        }
       
        private async Task OnWheel(WheelEventArgs e)
        {

            if (module == null) return;

            // Scroll up = zoom in, scroll down = zoom out
            double delta = e.DeltaY < 0 ? 0.02 : -0.02;
            double newZoom = Math.Clamp(Zoom + delta, MinZoom, MaxZoom);

            if (Math.Abs(newZoom - Zoom) < 0.001) return; // already at limit

            var rect = await module.InvokeAsync<DOMRect>("getBoundingClientRect", canvasRef);
            double mouseX = e.ClientX - rect.Left;
            double mouseY = e.ClientY - rect.Top;

            // Adjust offsets so zoom is centered at cursor
            //OffsetX = (int)(mouseX - (mouseX - OffsetX) * (newZoom / Zoom));
            //OffsetY = (int)(mouseY - (mouseY - OffsetY) * (newZoom / Zoom));

            Zoom = newZoom;

            await OnZoomed.InvokeAsync(Zoom);
            StateHasChanged();
        }

        public void SetViewport(CanvasProperties canvasProperties)
        {
            
        }
        public void SetOffset(int offsetX, int offsetY)
        {
            
        }

        public void SetZoom(double zoom)
        {
            Zoom = Math.Clamp(zoom, MinZoom, MaxZoom);
            StateHasChanged();
        }

        public CanvasProperties GetViewportProperties() =>
            new CanvasProperties
            {
                OffsetX = 0,
                OffsetY = 0,
                Zoom = Zoom
            };

        public void Dispose()
        {
            Graph.NodeAdded -= Refresh;
        }

        [JSInvokable]
        public async Task NotifyPanned(double offsetX, double offsetY)
        {
            await OnPanned.InvokeAsync(new PanEventArgs(offsetX, offsetY));
        }

        public async ValueTask DisposeAsync()
        {

            if(module != null)
            {
                await module.InvokeVoidAsync("removeCanvasEvents", canvasRef);
                dotnetObjRef?.Dispose();
                await module.DisposeAsync();
            }
        }
    }
}