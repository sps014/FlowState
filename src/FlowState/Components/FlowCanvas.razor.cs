// <autogenerated />
using System.Drawing;
using FlowState.Models;
using FlowState.Models.Dom;
using FlowState.Models.Events;
using FlowState.Models.Serializable;
using Microsoft.AspNetCore.Components;
using Microsoft.AspNetCore.Components.Web;
using Microsoft.JSInterop;

namespace FlowState.Components
{
    public partial class FlowCanvas : IAsyncDisposable
    {
        public string Id { get; } = Guid.NewGuid().ToString();

        [EditorRequired]
        [Parameter]
        public FlowGraph Graph { get; set; }

        [EditorRequired]
        [Parameter]
        public string Width { get; set; } = "100%";
        [EditorRequired]
        [Parameter]
        public string Height { get; set; } = "100%";
        [Parameter] public string Style { get; set; } = string.Empty;
        [Parameter] public string Class { get; set; } = "flow-canvas";

        [Parameter] public double MinZoom { get; set; } = 0.2;
        [Parameter] public double MaxZoom { get; set; } = 2.0;

        [Parameter] public double Zoom { get; set; } = 1.0;
        [Parameter] public EventCallback<PanEventArgs> OnPanned { get; set; }
        [Parameter] public EventCallback<double> OnZoomed { get; set; }

        [Parameter] public EventCallback<NodeMovedArg> OnNodeMoved { get; set; }

        /// <summary>
        /// Optional override for the background grid pattern.
        /// </summary>
        [Parameter] public string GridStyle { get; set; } = string.Empty;

        [Parameter] public Size GridBackgroundSize { get; set; } = new Size(32, 32);


        private ElementReference gridRef;
        private ElementReference canvasRef;
        private ElementReference flowContentRef;
        private IJSObjectReference module;

        private DotNetObjectReference<FlowCanvas> dotnetObjRef;

        // Default dotted grid pattern
        private const string DefaultGridStyle =
            """
        background-image:radial-gradient(#000 1px, transparent 1px);
        background-repeat:repeat;
        """;

        private string EffectiveGridStyle =>
          $"""
    position:absolute;
    inset:0;
    {(string.IsNullOrWhiteSpace(GridStyle) ? DefaultGridStyle : GridStyle)};
    background-size:{GridBackgroundSize.Width * Zoom}px {GridBackgroundSize.Height * Zoom}px;
    """;


        private string ContentStyle =>
            $"""
    position:absolute;
    top:0;left:0;
    transform-origin: 0 0;
    will-change:transform;
    """;

    protected override void OnInitialized()
        {
            if (Graph == null)
                throw new InvalidOperationException("FlowCanvas requires a valid FlowGraph instance.");
                
            Graph.Canvas = this;
            Graph.NodeAdded += Refresh;
            dotnetObjRef = DotNetObjectReference.Create(this);
        }

        protected override async Task OnAfterRenderAsync(bool firstRender)
        {
            await base.OnAfterRenderAsync(firstRender);

            if (!firstRender)
                return;

            module = await JS.InvokeAsync<IJSObjectReference>("import", "/_content/FlowState/flowCanvas.js");
            await module.InvokeVoidAsync("setGridBackgroundSize", GridBackgroundSize.Width, GridBackgroundSize.Height);
            await module.InvokeVoidAsync("setupCanvasEvents", canvasRef, gridRef, flowContentRef, dotnetObjRef);
            await SetViewportPropertiesAsync(new CanvasProperties { Zoom = Zoom, MinZoom = MinZoom, MaxZoom = MaxZoom });
        }

        private void Refresh(object sender, EventArgs e)
        {
            StateHasChanged();
        }

        public ValueTask SetViewportPropertiesAsync(CanvasProperties canvasProperties)
        {
            return module.InvokeVoidAsync("setCanvasProperties", canvasProperties);
        }

        public ValueTask<CanvasProperties> GetViewportPropertiesAsync()
        {
            return module.InvokeAsync<CanvasProperties>("getCanvasProperties");
        }
        public ValueTask SetOffsetAsync(int offsetX, int offsetY)
        {
            return module.InvokeVoidAsync("setOffset", offsetX, offsetY);
        }

        public ValueTask SetZoomAsync(double zoom)
        {
            return module.InvokeVoidAsync("setZoom", zoom);
        }


            

        public void Dispose()
        {
            Graph.NodeAdded -= Refresh;
        }

        [JSInvokable]
        public async Task NotifyPanned(double offsetX, double offsetY)
        {
            await OnPanned.InvokeAsync(new PanEventArgs(offsetX, offsetY));
        }

        [JSInvokable]
        public async Task NotifyZoomed(double zoom)
        {
            await OnZoomed.InvokeAsync(zoom);
        }

        [JSInvokable]
        public async Task NotifyNodeMoved(string nodeId, double x, double y)
        {
            await OnNodeMoved.InvokeAsync(new NodeMovedArg(nodeId, x, y));
        }

        public async ValueTask DisposeAsync()
        {

            if(module != null)
            {
                await module.InvokeVoidAsync("removeCanvasEvents", canvasRef);
                dotnetObjRef?.Dispose();
                await module.DisposeAsync();
            }
        }
    }
}